// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: responses.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// *** WSV data structure *** //
struct Iroha_Protocol_Asset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: String = String()

  var domainID: String = String()

  var precision: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_Domain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var domainID: String = String()

  var defaultRole: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_Account {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: String = String()

  var domainID: String = String()

  var quorum: UInt32 = 0

  var jsonData: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_AccountAsset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: String {
    get {return _storage._assetID}
    set {_uniqueStorage()._assetID = newValue}
  }

  var accountID: String {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  var balance: Iroha_Protocol_Amount {
    get {return _storage._balance ?? Iroha_Protocol_Amount()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  mutating func clearBalance() {_storage._balance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// *** Responses *** //
struct Iroha_Protocol_AccountAssetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountAssets: [Iroha_Protocol_AccountAsset] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_AccountDetailResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var detail: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_AccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: Iroha_Protocol_Account {
    get {return _storage._account ?? Iroha_Protocol_Account()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_storage._account = nil}

  var accountRoles: [String] {
    get {return _storage._accountRoles}
    set {_uniqueStorage()._accountRoles = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iroha_Protocol_AssetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var asset: Iroha_Protocol_Asset {
    get {return _storage._asset ?? Iroha_Protocol_Asset()}
    set {_uniqueStorage()._asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return _storage._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {_storage._asset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iroha_Protocol_RolesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var roles: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_RolePermissionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var permissions: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_ErrorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: Iroha_Protocol_ErrorResponse.Reason = .statelessInvalid

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Reason: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case statelessInvalid // = 0
    case statefulInvalid // = 1

    /// when requested account does not exist
    case noAccount // = 2

    /// when requested account asset does not exist
    case noAccountAssets // = 3

    /// when requested account detail does not exist
    case noAccountDetail // = 4

    /// when requested signatories does not exist
    case noSignatories // = 5

    /// when unidentified request was received
    case notSupported // = 6

    /// when requested asset does not exist
    case noAsset // = 7

    /// when there are no roles defined in the system
    case noRoles // = 8
    case UNRECOGNIZED(Int)

    init() {
      self = .statelessInvalid
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .statelessInvalid
      case 1: self = .statefulInvalid
      case 2: self = .noAccount
      case 3: self = .noAccountAssets
      case 4: self = .noAccountDetail
      case 5: self = .noSignatories
      case 6: self = .notSupported
      case 7: self = .noAsset
      case 8: self = .noRoles
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .statelessInvalid: return 0
      case .statefulInvalid: return 1
      case .noAccount: return 2
      case .noAccountAssets: return 3
      case .noAccountDetail: return 4
      case .noSignatories: return 5
      case .notSupported: return 6
      case .noAsset: return 7
      case .noRoles: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

struct Iroha_Protocol_SignatoriesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keys: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_TransactionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactions: [Iroha_Protocol_Transaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_QueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: OneOf_Response? {
    get {return _storage._response}
    set {_uniqueStorage()._response = newValue}
  }

  var accountAssetsResponse: Iroha_Protocol_AccountAssetResponse {
    get {
      if case .accountAssetsResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_AccountAssetResponse()
    }
    set {_uniqueStorage()._response = .accountAssetsResponse(newValue)}
  }

  var accountDetailResponse: Iroha_Protocol_AccountDetailResponse {
    get {
      if case .accountDetailResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_AccountDetailResponse()
    }
    set {_uniqueStorage()._response = .accountDetailResponse(newValue)}
  }

  var accountResponse: Iroha_Protocol_AccountResponse {
    get {
      if case .accountResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_AccountResponse()
    }
    set {_uniqueStorage()._response = .accountResponse(newValue)}
  }

  var errorResponse: Iroha_Protocol_ErrorResponse {
    get {
      if case .errorResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_ErrorResponse()
    }
    set {_uniqueStorage()._response = .errorResponse(newValue)}
  }

  var signatoriesResponse: Iroha_Protocol_SignatoriesResponse {
    get {
      if case .signatoriesResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_SignatoriesResponse()
    }
    set {_uniqueStorage()._response = .signatoriesResponse(newValue)}
  }

  var transactionsResponse: Iroha_Protocol_TransactionsResponse {
    get {
      if case .transactionsResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_TransactionsResponse()
    }
    set {_uniqueStorage()._response = .transactionsResponse(newValue)}
  }

  var assetResponse: Iroha_Protocol_AssetResponse {
    get {
      if case .assetResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_AssetResponse()
    }
    set {_uniqueStorage()._response = .assetResponse(newValue)}
  }

  var rolesResponse: Iroha_Protocol_RolesResponse {
    get {
      if case .rolesResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_RolesResponse()
    }
    set {_uniqueStorage()._response = .rolesResponse(newValue)}
  }

  var rolePermissionsResponse: Iroha_Protocol_RolePermissionsResponse {
    get {
      if case .rolePermissionsResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_RolePermissionsResponse()
    }
    set {_uniqueStorage()._response = .rolePermissionsResponse(newValue)}
  }

  var queryHash: String {
    get {return _storage._queryHash}
    set {_uniqueStorage()._queryHash = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case accountAssetsResponse(Iroha_Protocol_AccountAssetResponse)
    case accountDetailResponse(Iroha_Protocol_AccountDetailResponse)
    case accountResponse(Iroha_Protocol_AccountResponse)
    case errorResponse(Iroha_Protocol_ErrorResponse)
    case signatoriesResponse(Iroha_Protocol_SignatoriesResponse)
    case transactionsResponse(Iroha_Protocol_TransactionsResponse)
    case assetResponse(Iroha_Protocol_AssetResponse)
    case rolesResponse(Iroha_Protocol_RolesResponse)
    case rolePermissionsResponse(Iroha_Protocol_RolePermissionsResponse)

    static func ==(lhs: Iroha_Protocol_QueryResponse.OneOf_Response, rhs: Iroha_Protocol_QueryResponse.OneOf_Response) -> Bool {
      switch (lhs, rhs) {
      case (.accountAssetsResponse(let l), .accountAssetsResponse(let r)): return l == r
      case (.accountDetailResponse(let l), .accountDetailResponse(let r)): return l == r
      case (.accountResponse(let l), .accountResponse(let r)): return l == r
      case (.errorResponse(let l), .errorResponse(let r)): return l == r
      case (.signatoriesResponse(let l), .signatoriesResponse(let r)): return l == r
      case (.transactionsResponse(let l), .transactionsResponse(let r)): return l == r
      case (.assetResponse(let l), .assetResponse(let r)): return l == r
      case (.rolesResponse(let l), .rolesResponse(let r)): return l == r
      case (.rolePermissionsResponse(let l), .rolePermissionsResponse(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iroha_Protocol_BlockResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var block: Iroha_Protocol_Block {
    get {return _storage._block ?? Iroha_Protocol_Block()}
    set {_uniqueStorage()._block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return _storage._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {_storage._block = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iroha_Protocol_BlockErrorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_BlockQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: OneOf_Response? {
    get {return _storage._response}
    set {_uniqueStorage()._response = newValue}
  }

  var blockResponse: Iroha_Protocol_BlockResponse {
    get {
      if case .blockResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_BlockResponse()
    }
    set {_uniqueStorage()._response = .blockResponse(newValue)}
  }

  var errorResponse: Iroha_Protocol_BlockErrorResponse {
    get {
      if case .errorResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_BlockErrorResponse()
    }
    set {_uniqueStorage()._response = .errorResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case blockResponse(Iroha_Protocol_BlockResponse)
    case errorResponse(Iroha_Protocol_BlockErrorResponse)

    static func ==(lhs: Iroha_Protocol_BlockQueryResponse.OneOf_Response, rhs: Iroha_Protocol_BlockQueryResponse.OneOf_Response) -> Bool {
      switch (lhs, rhs) {
      case (.blockResponse(let l), .blockResponse(let r)): return l == r
      case (.errorResponse(let l), .errorResponse(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iroha.protocol"

extension Iroha_Protocol_Asset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Asset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .standard(proto: "domain_id"),
    3: .same(proto: "precision"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.assetID)
      case 2: try decoder.decodeSingularStringField(value: &self.domainID)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.precision)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assetID.isEmpty {
      try visitor.visitSingularStringField(value: self.assetID, fieldNumber: 1)
    }
    if !self.domainID.isEmpty {
      try visitor.visitSingularStringField(value: self.domainID, fieldNumber: 2)
    }
    if self.precision != 0 {
      try visitor.visitSingularUInt32Field(value: self.precision, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_Asset) -> Bool {
    if self.assetID != other.assetID {return false}
    if self.domainID != other.domainID {return false}
    if self.precision != other.precision {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_Domain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Domain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "domain_id"),
    2: .standard(proto: "default_role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.domainID)
      case 2: try decoder.decodeSingularStringField(value: &self.defaultRole)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domainID.isEmpty {
      try visitor.visitSingularStringField(value: self.domainID, fieldNumber: 1)
    }
    if !self.defaultRole.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultRole, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_Domain) -> Bool {
    if self.domainID != other.domainID {return false}
    if self.defaultRole != other.defaultRole {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Account"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "domain_id"),
    3: .same(proto: "quorum"),
    4: .standard(proto: "json_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.accountID)
      case 2: try decoder.decodeSingularStringField(value: &self.domainID)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.quorum)
      case 4: try decoder.decodeSingularStringField(value: &self.jsonData)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.domainID.isEmpty {
      try visitor.visitSingularStringField(value: self.domainID, fieldNumber: 2)
    }
    if self.quorum != 0 {
      try visitor.visitSingularUInt32Field(value: self.quorum, fieldNumber: 3)
    }
    if !self.jsonData.isEmpty {
      try visitor.visitSingularStringField(value: self.jsonData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_Account) -> Bool {
    if self.accountID != other.accountID {return false}
    if self.domainID != other.domainID {return false}
    if self.quorum != other.quorum {return false}
    if self.jsonData != other.jsonData {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_AccountAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountAsset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .standard(proto: "account_id"),
    3: .same(proto: "balance"),
  ]

  fileprivate class _StorageClass {
    var _assetID: String = String()
    var _accountID: String = String()
    var _balance: Iroha_Protocol_Amount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _assetID = source._assetID
      _accountID = source._accountID
      _balance = source._balance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._assetID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._accountID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._balance)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._assetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetID, fieldNumber: 1)
      }
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountID, fieldNumber: 2)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AccountAsset) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._assetID != other_storage._assetID {return false}
        if _storage._accountID != other_storage._accountID {return false}
        if _storage._balance != other_storage._balance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_AccountAssetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountAssetResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_assets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.accountAssets)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountAssets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountAssets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AccountAssetResponse) -> Bool {
    if self.accountAssets != other.accountAssets {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_AccountDetailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountDetailResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "detail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.detail)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.detail.isEmpty {
      try visitor.visitSingularStringField(value: self.detail, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AccountDetailResponse) -> Bool {
    if self.detail != other.detail {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_AccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "account_roles"),
  ]

  fileprivate class _StorageClass {
    var _account: Iroha_Protocol_Account? = nil
    var _accountRoles: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _accountRoles = source._accountRoles
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._accountRoles)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._accountRoles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._accountRoles, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AccountResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._account != other_storage._account {return false}
        if _storage._accountRoles != other_storage._accountRoles {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_AssetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssetResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asset"),
  ]

  fileprivate class _StorageClass {
    var _asset: Iroha_Protocol_Asset? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _asset = source._asset
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._asset)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._asset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AssetResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._asset != other_storage._asset {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_RolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RolesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.roles)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_RolesResponse) -> Bool {
    if self.roles != other.roles {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_RolePermissionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RolePermissionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permissions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.permissions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.permissions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_RolePermissionsResponse) -> Bool {
    if self.permissions != other.permissions {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_ErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ErrorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      case 2: try decoder.decodeSingularStringField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .statelessInvalid {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_ErrorResponse) -> Bool {
    if self.reason != other.reason {return false}
    if self.message != other.message {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_ErrorResponse.Reason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATELESS_INVALID"),
    1: .same(proto: "STATEFUL_INVALID"),
    2: .same(proto: "NO_ACCOUNT"),
    3: .same(proto: "NO_ACCOUNT_ASSETS"),
    4: .same(proto: "NO_ACCOUNT_DETAIL"),
    5: .same(proto: "NO_SIGNATORIES"),
    6: .same(proto: "NOT_SUPPORTED"),
    7: .same(proto: "NO_ASSET"),
    8: .same(proto: "NO_ROLES"),
  ]
}

extension Iroha_Protocol_SignatoriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignatoriesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.keys)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_SignatoriesResponse) -> Bool {
    if self.keys != other.keys {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_TransactionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_TransactionsResponse) -> Bool {
    if self.transactions != other.transactions {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_QueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_assets_response"),
    2: .standard(proto: "account_detail_response"),
    3: .standard(proto: "account_response"),
    4: .standard(proto: "error_response"),
    5: .standard(proto: "signatories_response"),
    6: .standard(proto: "transactions_response"),
    7: .standard(proto: "asset_response"),
    8: .standard(proto: "roles_response"),
    9: .standard(proto: "role_permissions_response"),
    10: .standard(proto: "query_hash"),
  ]

  fileprivate class _StorageClass {
    var _response: Iroha_Protocol_QueryResponse.OneOf_Response?
    var _queryHash: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _response = source._response
      _queryHash = source._queryHash
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Iroha_Protocol_AccountAssetResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .accountAssetsResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .accountAssetsResponse(v)}
        case 2:
          var v: Iroha_Protocol_AccountDetailResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .accountDetailResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .accountDetailResponse(v)}
        case 3:
          var v: Iroha_Protocol_AccountResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .accountResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .accountResponse(v)}
        case 4:
          var v: Iroha_Protocol_ErrorResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .errorResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .errorResponse(v)}
        case 5:
          var v: Iroha_Protocol_SignatoriesResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .signatoriesResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .signatoriesResponse(v)}
        case 6:
          var v: Iroha_Protocol_TransactionsResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .transactionsResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .transactionsResponse(v)}
        case 7:
          var v: Iroha_Protocol_AssetResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .assetResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .assetResponse(v)}
        case 8:
          var v: Iroha_Protocol_RolesResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .rolesResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .rolesResponse(v)}
        case 9:
          var v: Iroha_Protocol_RolePermissionsResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .rolePermissionsResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .rolePermissionsResponse(v)}
        case 10: try decoder.decodeSingularStringField(value: &_storage._queryHash)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._response {
      case .accountAssetsResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .accountDetailResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .accountResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .errorResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .signatoriesResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .transactionsResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .assetResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .rolesResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .rolePermissionsResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case nil: break
      }
      if !_storage._queryHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._queryHash, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_QueryResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._response != other_storage._response {return false}
        if _storage._queryHash != other_storage._queryHash {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_BlockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
  ]

  fileprivate class _StorageClass {
    var _block: Iroha_Protocol_Block? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _block = source._block
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._block)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._block {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_BlockResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._block != other_storage._block {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_BlockErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockErrorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_BlockErrorResponse) -> Bool {
    if self.message != other.message {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_BlockQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockQueryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_response"),
    2: .standard(proto: "error_response"),
  ]

  fileprivate class _StorageClass {
    var _response: Iroha_Protocol_BlockQueryResponse.OneOf_Response?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _response = source._response
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Iroha_Protocol_BlockResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .blockResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .blockResponse(v)}
        case 2:
          var v: Iroha_Protocol_BlockErrorResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .errorResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .errorResponse(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._response {
      case .blockResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .errorResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_BlockQueryResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._response != other_storage._response {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
