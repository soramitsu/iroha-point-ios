// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: commands.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Iroha_Protocol_AddAssetQuantity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: String {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  var assetID: String {
    get {return _storage._assetID}
    set {_uniqueStorage()._assetID = newValue}
  }

  var amount: Iroha_Protocol_Amount {
    get {return _storage._amount ?? Iroha_Protocol_Amount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {_storage._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iroha_Protocol_AddPeer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peer: Iroha_Protocol_Peer {
    get {return _storage._peer ?? Iroha_Protocol_Peer()}
    set {_uniqueStorage()._peer = newValue}
  }
  /// Returns true if `peer` has been explicitly set.
  var hasPeer: Bool {return _storage._peer != nil}
  /// Clears the value of `peer`. Subsequent reads from it will return its default value.
  mutating func clearPeer() {_storage._peer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iroha_Protocol_AddSignatory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: String = String()

  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_CreateAsset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetName: String = String()

  var domainID: String = String()

  var precision: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_CreateAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountName: String = String()

  var domainID: String = String()

  var mainPubkey: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_SetAccountDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: String = String()

  var key: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_CreateDomain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var domainID: String = String()

  var defaultRole: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_RemoveSignatory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: String = String()

  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_SetAccountQuorum {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: String = String()

  var quorum: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_TransferAsset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var srcAccountID: String {
    get {return _storage._srcAccountID}
    set {_uniqueStorage()._srcAccountID = newValue}
  }

  var destAccountID: String {
    get {return _storage._destAccountID}
    set {_uniqueStorage()._destAccountID = newValue}
  }

  var assetID: String {
    get {return _storage._assetID}
    set {_uniqueStorage()._assetID = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var amount: Iroha_Protocol_Amount {
    get {return _storage._amount ?? Iroha_Protocol_Amount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {_storage._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iroha_Protocol_AppendRole {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: String = String()

  var roleName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_DetachRole {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: String = String()

  var roleName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_CreateRole {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var roleName: String = String()

  var permissions: [Iroha_Protocol_RolePermission] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_GrantPermission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: String = String()

  var permission: Iroha_Protocol_GrantablePermission = .canAddMySignatory

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_RevokePermission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: String = String()

  var permission: Iroha_Protocol_GrantablePermission = .canAddMySignatory

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iroha_Protocol_SubtractAssetQuantity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: String {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  var assetID: String {
    get {return _storage._assetID}
    set {_uniqueStorage()._assetID = newValue}
  }

  var amount: Iroha_Protocol_Amount {
    get {return _storage._amount ?? Iroha_Protocol_Amount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {_storage._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iroha_Protocol_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: OneOf_Command? {
    get {return _storage._command}
    set {_uniqueStorage()._command = newValue}
  }

  var addAssetQuantity: Iroha_Protocol_AddAssetQuantity {
    get {
      if case .addAssetQuantity(let v)? = _storage._command {return v}
      return Iroha_Protocol_AddAssetQuantity()
    }
    set {_uniqueStorage()._command = .addAssetQuantity(newValue)}
  }

  var addPeer: Iroha_Protocol_AddPeer {
    get {
      if case .addPeer(let v)? = _storage._command {return v}
      return Iroha_Protocol_AddPeer()
    }
    set {_uniqueStorage()._command = .addPeer(newValue)}
  }

  var addSignatory: Iroha_Protocol_AddSignatory {
    get {
      if case .addSignatory(let v)? = _storage._command {return v}
      return Iroha_Protocol_AddSignatory()
    }
    set {_uniqueStorage()._command = .addSignatory(newValue)}
  }

  var appendRole: Iroha_Protocol_AppendRole {
    get {
      if case .appendRole(let v)? = _storage._command {return v}
      return Iroha_Protocol_AppendRole()
    }
    set {_uniqueStorage()._command = .appendRole(newValue)}
  }

  var createAccount: Iroha_Protocol_CreateAccount {
    get {
      if case .createAccount(let v)? = _storage._command {return v}
      return Iroha_Protocol_CreateAccount()
    }
    set {_uniqueStorage()._command = .createAccount(newValue)}
  }

  var createAsset: Iroha_Protocol_CreateAsset {
    get {
      if case .createAsset(let v)? = _storage._command {return v}
      return Iroha_Protocol_CreateAsset()
    }
    set {_uniqueStorage()._command = .createAsset(newValue)}
  }

  var createDomain: Iroha_Protocol_CreateDomain {
    get {
      if case .createDomain(let v)? = _storage._command {return v}
      return Iroha_Protocol_CreateDomain()
    }
    set {_uniqueStorage()._command = .createDomain(newValue)}
  }

  var createRole: Iroha_Protocol_CreateRole {
    get {
      if case .createRole(let v)? = _storage._command {return v}
      return Iroha_Protocol_CreateRole()
    }
    set {_uniqueStorage()._command = .createRole(newValue)}
  }

  var detachRole: Iroha_Protocol_DetachRole {
    get {
      if case .detachRole(let v)? = _storage._command {return v}
      return Iroha_Protocol_DetachRole()
    }
    set {_uniqueStorage()._command = .detachRole(newValue)}
  }

  var grantPermission: Iroha_Protocol_GrantPermission {
    get {
      if case .grantPermission(let v)? = _storage._command {return v}
      return Iroha_Protocol_GrantPermission()
    }
    set {_uniqueStorage()._command = .grantPermission(newValue)}
  }

  var removeSign: Iroha_Protocol_RemoveSignatory {
    get {
      if case .removeSign(let v)? = _storage._command {return v}
      return Iroha_Protocol_RemoveSignatory()
    }
    set {_uniqueStorage()._command = .removeSign(newValue)}
  }

  var revokePermission: Iroha_Protocol_RevokePermission {
    get {
      if case .revokePermission(let v)? = _storage._command {return v}
      return Iroha_Protocol_RevokePermission()
    }
    set {_uniqueStorage()._command = .revokePermission(newValue)}
  }

  var setAccountDetail: Iroha_Protocol_SetAccountDetail {
    get {
      if case .setAccountDetail(let v)? = _storage._command {return v}
      return Iroha_Protocol_SetAccountDetail()
    }
    set {_uniqueStorage()._command = .setAccountDetail(newValue)}
  }

  var setQuorum: Iroha_Protocol_SetAccountQuorum {
    get {
      if case .setQuorum(let v)? = _storage._command {return v}
      return Iroha_Protocol_SetAccountQuorum()
    }
    set {_uniqueStorage()._command = .setQuorum(newValue)}
  }

  var subtractAssetQuantity: Iroha_Protocol_SubtractAssetQuantity {
    get {
      if case .subtractAssetQuantity(let v)? = _storage._command {return v}
      return Iroha_Protocol_SubtractAssetQuantity()
    }
    set {_uniqueStorage()._command = .subtractAssetQuantity(newValue)}
  }

  var transferAsset: Iroha_Protocol_TransferAsset {
    get {
      if case .transferAsset(let v)? = _storage._command {return v}
      return Iroha_Protocol_TransferAsset()
    }
    set {_uniqueStorage()._command = .transferAsset(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Command: Equatable {
    case addAssetQuantity(Iroha_Protocol_AddAssetQuantity)
    case addPeer(Iroha_Protocol_AddPeer)
    case addSignatory(Iroha_Protocol_AddSignatory)
    case appendRole(Iroha_Protocol_AppendRole)
    case createAccount(Iroha_Protocol_CreateAccount)
    case createAsset(Iroha_Protocol_CreateAsset)
    case createDomain(Iroha_Protocol_CreateDomain)
    case createRole(Iroha_Protocol_CreateRole)
    case detachRole(Iroha_Protocol_DetachRole)
    case grantPermission(Iroha_Protocol_GrantPermission)
    case removeSign(Iroha_Protocol_RemoveSignatory)
    case revokePermission(Iroha_Protocol_RevokePermission)
    case setAccountDetail(Iroha_Protocol_SetAccountDetail)
    case setQuorum(Iroha_Protocol_SetAccountQuorum)
    case subtractAssetQuantity(Iroha_Protocol_SubtractAssetQuantity)
    case transferAsset(Iroha_Protocol_TransferAsset)

    static func ==(lhs: Iroha_Protocol_Command.OneOf_Command, rhs: Iroha_Protocol_Command.OneOf_Command) -> Bool {
      switch (lhs, rhs) {
      case (.addAssetQuantity(let l), .addAssetQuantity(let r)): return l == r
      case (.addPeer(let l), .addPeer(let r)): return l == r
      case (.addSignatory(let l), .addSignatory(let r)): return l == r
      case (.appendRole(let l), .appendRole(let r)): return l == r
      case (.createAccount(let l), .createAccount(let r)): return l == r
      case (.createAsset(let l), .createAsset(let r)): return l == r
      case (.createDomain(let l), .createDomain(let r)): return l == r
      case (.createRole(let l), .createRole(let r)): return l == r
      case (.detachRole(let l), .detachRole(let r)): return l == r
      case (.grantPermission(let l), .grantPermission(let r)): return l == r
      case (.removeSign(let l), .removeSign(let r)): return l == r
      case (.revokePermission(let l), .revokePermission(let r)): return l == r
      case (.setAccountDetail(let l), .setAccountDetail(let r)): return l == r
      case (.setQuorum(let l), .setQuorum(let r)): return l == r
      case (.subtractAssetQuantity(let l), .subtractAssetQuantity(let r)): return l == r
      case (.transferAsset(let l), .transferAsset(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iroha.protocol"

extension Iroha_Protocol_AddAssetQuantity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddAssetQuantity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "asset_id"),
    3: .same(proto: "amount"),
  ]

  fileprivate class _StorageClass {
    var _accountID: String = String()
    var _assetID: String = String()
    var _amount: Iroha_Protocol_Amount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountID = source._accountID
      _assetID = source._assetID
      _amount = source._amount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._accountID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._assetID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._amount)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountID, fieldNumber: 1)
      }
      if !_storage._assetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetID, fieldNumber: 2)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AddAssetQuantity) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._accountID != other_storage._accountID {return false}
        if _storage._assetID != other_storage._assetID {return false}
        if _storage._amount != other_storage._amount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_AddPeer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddPeer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peer"),
  ]

  fileprivate class _StorageClass {
    var _peer: Iroha_Protocol_Peer? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _peer = source._peer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._peer)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._peer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AddPeer) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._peer != other_storage._peer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_AddSignatory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddSignatory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.accountID)
      case 2: try decoder.decodeSingularBytesField(value: &self.publicKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AddSignatory) -> Bool {
    if self.accountID != other.accountID {return false}
    if self.publicKey != other.publicKey {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_CreateAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAsset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_name"),
    2: .standard(proto: "domain_id"),
    3: .same(proto: "precision"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.assetName)
      case 2: try decoder.decodeSingularStringField(value: &self.domainID)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.precision)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assetName.isEmpty {
      try visitor.visitSingularStringField(value: self.assetName, fieldNumber: 1)
    }
    if !self.domainID.isEmpty {
      try visitor.visitSingularStringField(value: self.domainID, fieldNumber: 2)
    }
    if self.precision != 0 {
      try visitor.visitSingularUInt32Field(value: self.precision, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_CreateAsset) -> Bool {
    if self.assetName != other.assetName {return false}
    if self.domainID != other.domainID {return false}
    if self.precision != other.precision {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_CreateAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_name"),
    2: .standard(proto: "domain_id"),
    3: .standard(proto: "main_pubkey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.accountName)
      case 2: try decoder.decodeSingularStringField(value: &self.domainID)
      case 3: try decoder.decodeSingularBytesField(value: &self.mainPubkey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountName.isEmpty {
      try visitor.visitSingularStringField(value: self.accountName, fieldNumber: 1)
    }
    if !self.domainID.isEmpty {
      try visitor.visitSingularStringField(value: self.domainID, fieldNumber: 2)
    }
    if !self.mainPubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.mainPubkey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_CreateAccount) -> Bool {
    if self.accountName != other.accountName {return false}
    if self.domainID != other.domainID {return false}
    if self.mainPubkey != other.mainPubkey {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_SetAccountDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAccountDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "key"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.accountID)
      case 2: try decoder.decodeSingularStringField(value: &self.key)
      case 3: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_SetAccountDetail) -> Bool {
    if self.accountID != other.accountID {return false}
    if self.key != other.key {return false}
    if self.value != other.value {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_CreateDomain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateDomain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "domain_id"),
    2: .standard(proto: "default_role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.domainID)
      case 2: try decoder.decodeSingularStringField(value: &self.defaultRole)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domainID.isEmpty {
      try visitor.visitSingularStringField(value: self.domainID, fieldNumber: 1)
    }
    if !self.defaultRole.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultRole, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_CreateDomain) -> Bool {
    if self.domainID != other.domainID {return false}
    if self.defaultRole != other.defaultRole {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_RemoveSignatory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveSignatory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.accountID)
      case 2: try decoder.decodeSingularBytesField(value: &self.publicKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_RemoveSignatory) -> Bool {
    if self.accountID != other.accountID {return false}
    if self.publicKey != other.publicKey {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_SetAccountQuorum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAccountQuorum"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "quorum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.accountID)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.quorum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if self.quorum != 0 {
      try visitor.visitSingularUInt32Field(value: self.quorum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_SetAccountQuorum) -> Bool {
    if self.accountID != other.accountID {return false}
    if self.quorum != other.quorum {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_TransferAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransferAsset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "src_account_id"),
    2: .standard(proto: "dest_account_id"),
    3: .standard(proto: "asset_id"),
    4: .same(proto: "description"),
    5: .same(proto: "amount"),
  ]

  fileprivate class _StorageClass {
    var _srcAccountID: String = String()
    var _destAccountID: String = String()
    var _assetID: String = String()
    var _description_p: String = String()
    var _amount: Iroha_Protocol_Amount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _srcAccountID = source._srcAccountID
      _destAccountID = source._destAccountID
      _assetID = source._assetID
      _description_p = source._description_p
      _amount = source._amount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._srcAccountID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._destAccountID)
        case 3: try decoder.decodeSingularStringField(value: &_storage._assetID)
        case 4: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._amount)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._srcAccountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._srcAccountID, fieldNumber: 1)
      }
      if !_storage._destAccountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._destAccountID, fieldNumber: 2)
      }
      if !_storage._assetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetID, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_TransferAsset) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._srcAccountID != other_storage._srcAccountID {return false}
        if _storage._destAccountID != other_storage._destAccountID {return false}
        if _storage._assetID != other_storage._assetID {return false}
        if _storage._description_p != other_storage._description_p {return false}
        if _storage._amount != other_storage._amount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_AppendRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppendRole"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "role_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.accountID)
      case 2: try decoder.decodeSingularStringField(value: &self.roleName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.roleName.isEmpty {
      try visitor.visitSingularStringField(value: self.roleName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AppendRole) -> Bool {
    if self.accountID != other.accountID {return false}
    if self.roleName != other.roleName {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_DetachRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DetachRole"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "role_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.accountID)
      case 2: try decoder.decodeSingularStringField(value: &self.roleName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.roleName.isEmpty {
      try visitor.visitSingularStringField(value: self.roleName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_DetachRole) -> Bool {
    if self.accountID != other.accountID {return false}
    if self.roleName != other.roleName {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_CreateRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateRole"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "role_name"),
    2: .same(proto: "permissions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.roleName)
      case 2: try decoder.decodeRepeatedEnumField(value: &self.permissions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roleName.isEmpty {
      try visitor.visitSingularStringField(value: self.roleName, fieldNumber: 1)
    }
    if !self.permissions.isEmpty {
      try visitor.visitPackedEnumField(value: self.permissions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_CreateRole) -> Bool {
    if self.roleName != other.roleName {return false}
    if self.permissions != other.permissions {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_GrantPermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GrantPermission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "permission"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.accountID)
      case 2: try decoder.decodeSingularEnumField(value: &self.permission)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if self.permission != .canAddMySignatory {
      try visitor.visitSingularEnumField(value: self.permission, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_GrantPermission) -> Bool {
    if self.accountID != other.accountID {return false}
    if self.permission != other.permission {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_RevokePermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevokePermission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "permission"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.accountID)
      case 2: try decoder.decodeSingularEnumField(value: &self.permission)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if self.permission != .canAddMySignatory {
      try visitor.visitSingularEnumField(value: self.permission, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_RevokePermission) -> Bool {
    if self.accountID != other.accountID {return false}
    if self.permission != other.permission {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_SubtractAssetQuantity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubtractAssetQuantity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "asset_id"),
    3: .same(proto: "amount"),
  ]

  fileprivate class _StorageClass {
    var _accountID: String = String()
    var _assetID: String = String()
    var _amount: Iroha_Protocol_Amount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountID = source._accountID
      _assetID = source._assetID
      _amount = source._amount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._accountID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._assetID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._amount)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountID, fieldNumber: 1)
      }
      if !_storage._assetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetID, fieldNumber: 2)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_SubtractAssetQuantity) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._accountID != other_storage._accountID {return false}
        if _storage._assetID != other_storage._assetID {return false}
        if _storage._amount != other_storage._amount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Command"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "add_asset_quantity"),
    2: .standard(proto: "add_peer"),
    3: .standard(proto: "add_signatory"),
    4: .standard(proto: "append_role"),
    5: .standard(proto: "create_account"),
    6: .standard(proto: "create_asset"),
    7: .standard(proto: "create_domain"),
    8: .standard(proto: "create_role"),
    9: .standard(proto: "detach_role"),
    10: .standard(proto: "grant_permission"),
    11: .standard(proto: "remove_sign"),
    12: .standard(proto: "revoke_permission"),
    13: .standard(proto: "set_account_detail"),
    14: .standard(proto: "set_quorum"),
    15: .standard(proto: "subtract_asset_quantity"),
    16: .standard(proto: "transfer_asset"),
  ]

  fileprivate class _StorageClass {
    var _command: Iroha_Protocol_Command.OneOf_Command?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _command = source._command
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Iroha_Protocol_AddAssetQuantity?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .addAssetQuantity(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .addAssetQuantity(v)}
        case 2:
          var v: Iroha_Protocol_AddPeer?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .addPeer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .addPeer(v)}
        case 3:
          var v: Iroha_Protocol_AddSignatory?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .addSignatory(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .addSignatory(v)}
        case 4:
          var v: Iroha_Protocol_AppendRole?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .appendRole(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .appendRole(v)}
        case 5:
          var v: Iroha_Protocol_CreateAccount?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .createAccount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .createAccount(v)}
        case 6:
          var v: Iroha_Protocol_CreateAsset?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .createAsset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .createAsset(v)}
        case 7:
          var v: Iroha_Protocol_CreateDomain?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .createDomain(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .createDomain(v)}
        case 8:
          var v: Iroha_Protocol_CreateRole?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .createRole(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .createRole(v)}
        case 9:
          var v: Iroha_Protocol_DetachRole?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .detachRole(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .detachRole(v)}
        case 10:
          var v: Iroha_Protocol_GrantPermission?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .grantPermission(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .grantPermission(v)}
        case 11:
          var v: Iroha_Protocol_RemoveSignatory?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .removeSign(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .removeSign(v)}
        case 12:
          var v: Iroha_Protocol_RevokePermission?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .revokePermission(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .revokePermission(v)}
        case 13:
          var v: Iroha_Protocol_SetAccountDetail?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .setAccountDetail(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .setAccountDetail(v)}
        case 14:
          var v: Iroha_Protocol_SetAccountQuorum?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .setQuorum(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .setQuorum(v)}
        case 15:
          var v: Iroha_Protocol_SubtractAssetQuantity?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .subtractAssetQuantity(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .subtractAssetQuantity(v)}
        case 16:
          var v: Iroha_Protocol_TransferAsset?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .transferAsset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .transferAsset(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._command {
      case .addAssetQuantity(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .addPeer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .addSignatory(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .appendRole(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .createAccount(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .createAsset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .createDomain(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .createRole(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .detachRole(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .grantPermission(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .removeSign(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .revokePermission(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .setAccountDetail(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .setQuorum(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .subtractAssetQuantity(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .transferAsset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_Command) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._command != other_storage._command {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
